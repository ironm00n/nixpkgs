From ce2f73f6817e2e8d698cfb3fe3252eca2e71d57a Mon Sep 17 00:00:00 2001
From: Randy Eckenrode <randy@largeandhighquality.com>
Date: Sun, 4 Jan 2026 14:37:05 -0500
Subject: [PATCH] clang-importer-libcxx

---
 lib/ClangImporter/ClangImporter.cpp | 24 ++++++++++++++++++++++++
 1 file changed, 24 insertions(+)

diff --git a/lib/ClangImporter/ClangImporter.cpp b/lib/ClangImporter/ClangImporter.cpp
index 47361b38a0f..8b7b93b9175 100644
--- a/lib/ClangImporter/ClangImporter.cpp
+++ b/lib/ClangImporter/ClangImporter.cpp
@@ -565,6 +565,30 @@ void importer::getNormalInvocationArguments(
   }
 
   if (LangOpts.EnableCXXInterop) {
+    // Ensure the libc++ headers are available.
+    if (auto nixCC = ::getenv("NIX_CC")) {
+      llvm::BumpPtrAllocator allocator;
+      llvm::StringSaver saver(allocator);
+
+      // Treat `libcxx-cxxflags` as a response file for Clang. Because Clang
+      // expects response files to be expanded already at this point, it has
+      // to be expanded manually.
+      llvm::SmallString<256> path = StringRef(nixCC);
+      llvm::sys::path::append(path, "nix-support", "libcxx-cxxflags");
+      if (auto buffer = llvm::vfs::getRealFileSystem()->getBufferForFile(path)) {
+        auto contents = (*buffer)->getMemBufferRef().getBuffer();
+        llvm::SmallVector<const char*> args;
+#if _WIN32
+        llvm::cl::TokenizeWindowsCommandLineNoCopy(contents, saver, args);
+#else
+        llvm::cl::TokenizeGNUCommandLine(contents, saver, args);
+#endif
+        for (auto arg : args) {
+          invocationArgStrs.push_back(arg);
+        }
+      }
+    }
+
     if (auto path = getCxxShimModuleMapPath(searchPathOpts, LangOpts, triple)) {
       invocationArgStrs.push_back((Twine("-fmodule-map-file=") + *path).str());
     }
-- 
2.51.2

